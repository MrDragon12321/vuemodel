<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <input type="text" id="test">
    <span id="test1"></span>
    <script>
        // call和apply实现方式类似，只是传参的区别
           // 基本思想是把fn.call(obj,args)中的fn赋值为obj的属性，然后调用obj.fn即可实现fn中this指向的改变
           Function.prototype.myCall = function (context = window) { //myCall函数的参数，没有传参默认是指向window
            
               context.fn = this //为对象添加方法（this指向调用myCall的函数）
               console.log('context>>>',context);
               let args = [...arguments].slice(1) // 剩余的参数
               let res = context.fn(...args)  // 调用该方法，该方法this指向context
               delete context.fn //删除添加的方法
               return res
           }
           Function.prototype.myApply = function (context = window) { //myCall函数的参数，没有传参默认是指向window
               context.fn = this //为对象添加方法（this指向调用myCall的函数）
               let res
               if (arguments[1]) { //判断是否有第二个参数
                   res = context.fn(...arguments[1])// 调用该方法，该方法this指向context
               } else {
                   res = context.fn()// 调用该方法，该方法this指向context
               }
               delete context.fn //删除添加的方法
               return res
           }
           // 验证
           function sayName(name = 'wwx', age = 18) {
               console.log(...arguments);
               console.log(this)
               this.name = name
               this.age = age
               console.log(this)
               return this.age
           }
              console.dir(sayName)
           var obj = {
               name: 'zcf',
               age: 24
           }
           var age = sayName.myCall(obj, "wxxka") // 19
        //    var age1 = sayName.myApply(obj, ["wwxSSS", 20]) //20 

       

       
    </script>
</body>

</html>